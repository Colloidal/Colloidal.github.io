{"title":"关于初识UML与设计模式","date":"2019-11-13T21:10:56.164Z","link":"post/Design_Pattens_Singleton","tags":["丢人分享","初学笔记"],"categories":["开发经验"],"updated":"2019-11-14T02:03:28.601Z","content":"<hr>\n<blockquote>\n<p>胶某最近在打算把以前实现的功能都好好封装起来，于是为了代码更加优雅，耦合度更低，增强其可复用性，就必须对设计模式进行进一步的深入学习。<br>想想正好赶上例会，于是开始写了这篇文章进行总结，希望不会在分享会上丢人吧 <strong>:‘(</strong></p>\n<blockquote>\n<hr>\n<p>在这篇文章中，您可以看到：</p>\n<ul>\n<li><p>关于UML语言的新手教程；(因时间不足而暂且咕)</p>\n</li>\n<li><p>关于UML类图；(因时间不足而暂且咕)</p>\n</li>\n<li><p>关于设计模式的入门知识；</p>\n</li>\n<li><p>关于设计模式之一单例模式的介绍；</p>\n</li>\n<li><p>胶某在让她的代码看起来没这么糟糕上的尝试。</p>\n</li>\n</ul>\n</blockquote>\n</blockquote>\n<hr>\n<h1 id=\"初步认识设计模式\">初步认识设计模式<a href=\"post/Design_Pattens_Singleton#初步认识设计模式\"></a></h1><p>设计模式是面向对象设计的重要内容。</p>\n<p>当您着手开发一个项目时，如果您随心所欲地设计代码，不去考虑耦合度，可拓展性等问题，那么您将可能沉浸在重复造轮子的轮回中，开发成本和周期将可能迎来无意义的增加与延长。</p>\n<p>并且当项目越滚越大时，想要管理维护您所写的代码的难度将会大大提高，这是各位开发者们所都不愿看到的。</p>\n<p>同时，若您正好与伙伴一起协作开发一个项目，那么如果您不留意代码的设计与部署，您的伙伴在没有您的陪伴下将可能会难以独自理解您的代码，您的伙伴可能需要花费大量时间阅读您所编写的文档，导致您与伙伴无法更快速有效地进行协作开发，甚至可能会使您在合并工程时出现冲突。</p>\n<p>况且，在开发过程种自然地使用各种设计模式，您的代码看上去也会更加优雅，<del>作为一位程序员，这个理由难道还不够香吗?</del> </p>\n<p>设计模式并不是什么很难的知识，它只是关于代码设计的经验总结，因此相信您在稍微理解过后就能将它运用到实际开发中。 <strong>:D</strong></p>\n<h2 id=\"设计模式的规则\">设计模式的规则<a href=\"post/Design_Pattens_Singleton#设计模式的规则\"></a></h2><p>为了使设计模式运用时可以让代码拥有可拓展性、便于管理维护以及低耦合度等优秀特性，前辈们定下了一些好的设计模式应该符合的原则。</p>\n<p>① 单一职责原则</p>\n<p>一个类 = 功能的最小集与职责的不重合。</p>\n<blockquote>\n<p>如果一个类承担的职责过多(即耦合性太高)，将会导致您在使用该代码实现某个功能时，您还需要去注意其他功能职责的设置，这将使代码复用性大大降低</p>\n<blockquote>\n<p>例子：胶某为某个游戏编写了一个rpg角色控制器CharaController.cs，在此脚本中实现了角色移动、跳跃、对话系统与物品管理。当后来胶某想要制作tps游戏时，同样也需要实现角色移动与跳跃，但CharaController.cs将因为rpg特有的对话系统与物品管理而不适用tps游戏上。</p>\n</blockquote>\n</blockquote>\n<p>② 开放封闭原则</p>\n<p>一个实体应该对外扩展开放，对内修改关闭</p>\n<blockquote>\n<p>当增加功能时，您要通过添加新的代码来装饰增强，而不是直接修改原有的代码。</p>\n<blockquote>\n</blockquote>\n</blockquote>\n<p>③ 里氏代替原则</p>\n<p>子类必须替换掉它们的父类型。</p>\n<blockquote>\n<p>在软件开发过程中，子类替换父类后，程序的行为是一样的。</p>\n<p>只有当子类替换掉父类后软件的功能不受影响时，父类才能真正地被复用，而子类也可以在父类的基础上添加新的行为。</p>\n</blockquote>\n<p>④ 依赖倒置原则</p>\n<p>细节应该依赖于抽象，而抽象不应该依赖于细节。</p>\n<blockquote>\n<p>所谓的的 “面向接口编程，而不是面向实现编程”。这样可以降低客户与具体实现的耦合。</p>\n</blockquote>\n<p>⑤ 接口隔离原则</p>\n<p>使用多个专门功能的接口，而不是使用单一的总接口。</p>\n<blockquote>\n<p>不要让一个单一的接口承担过多的职责，而应把每个职责分离到多个专门的接口中，进行接口分离。</p>\n</blockquote>\n<p>⑥ 合成复用原则</p>\n<p>在一个新的对象里面使用一些已有的对象，使之成为新对象的一部分。</p>\n<blockquote>\n<p>新对象通过向这些对象的委派达到复用已用功能的目的。简单地说，就是要尽量使用合成/聚合，尽量不要使用继承。</p>\n</blockquote>\n<p>⑦ 最少知识原则（迪米特法则）</p>\n<p>一个模块或对象应尽量少的与其他实体之间发生相互作用，使得系统功能模块相对独立，这样当一个模块修改时，影响的模块就会越少，扩展起来更加容易。</p>\n<blockquote>\n<p>关于迪米特法则的其他描述：只与你直接的朋友们通信；不要跟“陌生人”说话。</p>\n</blockquote>\n<h2 id=\"23种设计模式分类\">23种设计模式分类<a href=\"post/Design_Pattens_Singleton#23种设计模式分类\"></a></h2><p>23种设计模式可以分为以下三大类：</p>\n<div class=\"article-bounded\"><div class=\"article-table\"><table>\n<thead>\n<tr>\n<th><strong>创建型模式：</strong></th>\n<th><strong>结构型模式</strong></th>\n<th><strong>行为型模式</strong></th>\n</tr>\n</thead>\n<tbody><tr>\n<td>工厂方法模式</td>\n<td>适配器模式</td>\n<td>策略模式</td>\n</tr>\n<tr>\n<td>工厂方法模式</td>\n<td>装饰器模式</td>\n<td>模板方法模式</td>\n</tr>\n<tr>\n<td>抽象工厂模式</td>\n<td>代理模式</td>\n<td>观察者模式</td>\n</tr>\n<tr>\n<td>单例模式</td>\n<td>外观模式</td>\n<td>迭代子模式</td>\n</tr>\n<tr>\n<td>建造者模式</td>\n<td>桥接模式</td>\n<td>责任链模式</td>\n</tr>\n<tr>\n<td>原型模式</td>\n<td>组合模式</td>\n<td>命令模式</td>\n</tr>\n<tr>\n<td></td>\n<td>享元模式</td>\n<td>备忘录模式</td>\n</tr>\n<tr>\n<td></td>\n<td></td>\n<td>备忘录模式</td>\n</tr>\n<tr>\n<td></td>\n<td></td>\n<td>访问者模式</td>\n</tr>\n<tr>\n<td></td>\n<td></td>\n<td>中介者模式</td>\n</tr>\n<tr>\n<td></td>\n<td></td>\n<td>解释器模式</td>\n</tr>\n</tbody></table></div></div>\n<h1 id=\"实践案例——单例模式Singleton\">实践案例——单例模式Singleton<a href=\"post/Design_Pattens_Singleton#实践案例——单例模式Singleton\"></a></h1><h2 id=\"关于什么是单例模式\">关于什么是单例模式<a href=\"post/Design_Pattens_Singleton#关于什么是单例模式\"></a></h2><p>单例模式是一种常用的设计模式，旨在保证一个类只有一个实例存在，其他类只能调用其访问点得到这个实例。</p>\n<p>在开发中，单例对象能保证在一整个项目中，该对象只有一个实例存在。不同于类可以被创建多个对象，使用单例模式编写的类只能自己内部创建一个对象，其他类只能调用该对象进行使用。</p>\n<p>单例模式既然存在，那必然有需要它存在的情况：</p>\n<ul>\n<li>单例模式下的对象只有一个，且其他类只能调用其自身实例化的唯一对象，控制了资源通信的一致性，因此单例模式可以很好地满足在不同类中调用同一个对象时的需求。 </li>\n<li>当某些类本身比较大型且创建比较频繁，如果这个类并不需要多个对象分开看待，使用单例模式可以省去了重复使用new进行对象创建的行为，降低了系统内存的使用频率，减轻GC压力，节省一笔的系统开销。</li>\n</ul>\n<h2 id=\"关于单例模式的实现\">关于单例模式的实现<a href=\"post/Design_Pattens_Singleton#关于单例模式的实现\"></a></h2><p>单例模式的核心是构造函数private化并提供一个返回唯一对象的public方法。</p>\n<h3 id=\"c-的懒汉式实现\">c#的懒汉式实现<a href=\"post/Design_Pattens_Singleton#c-的懒汉式实现\"></a></h3><p>懒汉式指在该类被加载时并不会直接实例化单例对象，而是在需要调用此单例对象时才会初始化创建该单例对象。</p>\n<p>如此可以避免内存浪费，但这并不能保证在多线程中同步，虽然可以靠加锁来保证多线程安全，但会造成额外的开销。</p>\n<pre><code>public class LazySingleton\n{\n    private static LazySingleton _instance;    //声明但不创建单例对象\n    private LazySingleton(){}                //私有化构造方法进行保护\n    public static LazySingleton Instance    //若单例对象未创建，则创建后返回此对象；若已创建，则直接返回单例对象。\n    {\n        get\n        {\n            if (_instance== null)\n            {\n                _instance= new LazySingleton();\n            }\n            return _instance;\n        }\n    }\n}</code></pre><h3 id=\"C-中的饿汉式实现\">C#中的饿汉式实现<a href=\"post/Design_Pattens_Singleton#C-中的饿汉式实现\"></a></h3><p>饿汉模式指在程序启动时类加载就直接初始化创建一个单例对象并一直存在下去。</p>\n<p>作为与类加载同步的初始化创建保证了多线程同步，故饿汉式单例模式可以多线程正常工作，但是因为一开始不管使用与否即实例化单例对象，可能会导致产生垃圾对象造成内存浪费。</p>\n<pre><code>public class StraveSingleton\n{\n    private static StraveSingleton _instance=new StraveSingleton();    //声明并创建单例对象\n    private StraveSingleton(){}             //私有化构造方法进行保护\n    public static StraveSingleton Instance    //返回唯一的单例对象\n    {\n        get\n        {\n            return _instance;\n        }\n    }\n}</code></pre><h3 id=\"Unity中继承MonoBehaviour下的单例\">Unity中继承MonoBehaviour下的单例<a href=\"post/Design_Pattens_Singleton#Unity中继承MonoBehaviour下的单例\"></a></h3><blockquote>\n<p>Unity是一个游戏开发引擎，MoniBehaviour是其脚本基类。</p>\n</blockquote>\n<p>在游戏开发过程中，单例模式可以说是十分常用的设计模式了。Unity贴心地为它的开发者们准备了方便的API实现单例模式。</p>\n<p>由于在Unity中，一个脚本需要挂载才可以被实例化使用。因此在Scene中只能有一个gameObject挂载此脚本并创建单例对象。在其他类中通过Singleton.instance得到的对象就是该物体上挂载的脚本对象。</p>\n<pre><code>using UnityEngine;\npublic class Singleton : MonoBehaviour {\n    private Singleton() { }                //私有化构造方法进行保护\n    public static Singleton _instance;    //声明单例对象\n    void Awake () {\n        _instance = this;                //创建单例对象\n    }\n\n}</code></pre><h2 id=\"关于单例模式的实例讲解\">关于单例模式的实例讲解<a href=\"post/Design_Pattens_Singleton#关于单例模式的实例讲解\"></a></h2><h3 id=\"绕过Time类的时间控制\">绕过Time类的时间控制<a href=\"post/Design_Pattens_Singleton#绕过Time类的时间控制\"></a></h3><ul>\n<li>背景：在游戏过程中，暂停功能使玩家可以随时休息或暂时离开去处理事请。</li>\n<li>问题：尽管Unity的MonoBehaviour下拥有时间管理的子类Time，一般情况下，利用更改其timescale的方法即可使场景中所有gameObject(除UGUI外)上挂载的继承自MonoBehaviour的生命周期与协程等运行暂停。但在实际运用中，这个暂停范围太大了。场景中常会有一些脚本我们不希望它被暂停，但它又必须被挂载在场景中的gameObject上。</li>\n<li>解决办法：使用单例模式，构造全局唯一单例对象将暂停的信息广播给需要暂停控制的对象。</li>\n<li>优点：可以部分控制Scene中的gameObject进行暂停，且其他gameObject的运行不受到影响。<h3 id=\"唯一控制核心\"><a href=\"#唯一控制核心\" class=\"headerlink\" title=\"唯一控制核心\"></a>唯一控制核心</h3></li>\n<li>背景：在某些小游戏中，多个玩家可以在准备页面进行个性化选择，并且在游戏进行中动态加载其选择。</li>\n<li>问题：在开发游戏的过程中，脚本都是挂载在scene的gameObject上，于是当切换scene时，原本挂载在gameObject上的脚本数据会被释放掉。</li>\n<li>解决办法：使用单例模式，构造全局唯一单例对象储存Scene间的共享信息。</li>\n<li>优点：使scene之间进行数据通信与处理，同时保证了信息的唯一性，使游戏中各gameObject都调用一致的数据信息进行同步。</li>\n</ul>\n","next":{"title":"关于Unity3D脚本的生命周期函数以及协程","link":"post/Unity_Lifecycle_Coroutine"},"plink":"http://blog.ColloidalZhao.com/post/Design_Pattens_Singleton/","toc":[{"title":"初步认识设计模式","id":"初步认识设计模式","index":"1","children":[{"title":"设计模式的规则","id":"设计模式的规则","index":"1.1"},{"title":"23种设计模式分类","id":"23种设计模式分类","index":"1.2"}]},{"title":"实践案例——单例模式Singleton","id":"实践案例——单例模式Singleton","index":"2","children":[{"title":"关于什么是单例模式","id":"关于什么是单例模式","index":"2.1"},{"title":"关于单例模式的实现","id":"关于单例模式的实现","index":"2.2","children":[{"title":"c#的懒汉式实现","id":"c-的懒汉式实现","index":"2.2.1"},{"title":"C#中的饿汉式实现","id":"C-中的饿汉式实现","index":"2.2.2"},{"title":"Unity中继承MonoBehaviour下的单例","id":"Unity中继承MonoBehaviour下的单例","index":"2.2.3"}]},{"title":"关于单例模式的实例讲解","id":"关于单例模式的实例讲解","index":"2.3","children":[{"title":"绕过Time类的时间控制","id":"绕过Time类的时间控制","index":"2.3.1"},{"title":"","id":"唯一控制核心","index":"2.3.2"}]}]}]}