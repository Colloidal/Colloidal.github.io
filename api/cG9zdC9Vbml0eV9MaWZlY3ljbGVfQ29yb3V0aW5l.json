{"title":"关于Unity3D脚本的生命周期函数以及协程","date":"2019-11-10T02:11:39.074Z","link":"post/Unity_Lifecycle_Coroutine","tags":["丢人分享","回顾思考"],"categories":["Unity3D"],"updated":"2019-11-09T22:26:31.583Z","content":"<hr>\n<blockquote>\n<p>记得招某在刚开始尝试自己学着做游戏时，只能按理所当然的想法去理解Unity中生命周期函数的运行。<br>同时对于协程，也只是肤浅的认为是一个”可以被控制的update函数”。<br>后来随着自己学习的深入，招某认为应该回过头来认真认识一下这个来自Unity的方便工具了。<del>并且也是时候尝试更新下blog了!!!</del></p>\n<blockquote>\n<p>在这篇文章中，您可以了解：</p>\n<ul>\n<li><p>Unity3D的生命周期函数的原理与运行规律；</p>\n</li>\n<li><p>理解协程的存在与使用；</p>\n</li>\n<li><p>利用协程进行一些简单功能的实现。</p>\n</li>\n</ul>\n</blockquote>\n</blockquote>\n<hr>\n<h1 id=\"关于Unity的生命周期函数-Lifecycle\">关于Unity的生命周期函数(Lifecycle)<a href=\"post/Unity_Lifecycle_Coroutine#关于Unity的生命周期函数-Lifecycle\"></a></h1><ul>\n<li>这部分内容十分简单，考虑到各位已经都上手尝试过学习Unity，故此处我将只简单整理一下一整个生命周期函数的前后顺序以及一些可能会踩到的坑。</li>\n</ul>\n<h2 id=\"首次加载-First-Scene-load\">首次加载(First Scene load)<a href=\"post/Unity_Lifecycle_Coroutine#首次加载-First-Scene-load\"></a></h2><ul>\n<li>Awake()：相信各位都知道，awake是场景中最先调用的函数，那么，其究竟有多早呢？其又与Start()有何区别呢?</li>\n</ul>\n<blockquote>\n<p>我们可以做个小实验：当gameobject运行前为inactive时，以及该script为disable时，还有完全实例化时分别输出console信息。</p>\n</blockquote>\n<h2 id=\"协程-Coroutine\">协程(Coroutine)<a href=\"post/Unity_Lifecycle_Coroutine#协程-Coroutine\"></a></h2><ul>\n<li>根据其被挂起的条件不同，会有不同的执行顺序。您也可以看到，协程可以很方便的在生命周期函数中的许多位置重新唤醒，方便我们执行代码，具体的我们会在后面细讲。</li>\n</ul>\n<h2 id=\"更新顺序-Update-Order\">更新顺序(Update Order)<a href=\"post/Unity_Lifecycle_Coroutine#更新顺序-Update-Order\"></a></h2><ul>\n<li>FixedUpdate()： FixedUpdate通常比Update()更频繁地被调用。如果帧速率低，则可以每帧多次调用它；如果帧速率高，则可以在帧之间根本不调用它。</li>\n</ul>\n<blockquote>\n<p>所有物理计算和更新都在FixedUpdate之后立即进行。在FixedUpdate中应用运动计算时，无需将值乘以Time.deltaTime。这是因为在可靠的计时器上调用了FixedUpdate，而与帧速率无关。</p>\n</blockquote>\n<ul>\n<li><p>Update()： 每帧渲染完毕后调用一次更新。</p>\n</li>\n<li><p>LateUpdate()： Update()完成后，每帧调用一次LateUpdate。LateUpdate开始时，Update中执行的所有计算都将完成。</p>\n</li>\n</ul>\n<blockquote>\n<p>LateUpdate的常见用法是后续的第三人称相机。如果使角色移动并在Update内部旋转，则可以在LateUpdate中执行所有摄像机的移动和旋转计算。这将确保角色在摄像机跟踪其位置之前已完全移动。</p>\n</blockquote>\n<hr>\n<h1 id=\"关于协程-Coroutine\">关于协程(Coroutine)<a href=\"post/Unity_Lifecycle_Coroutine#关于协程-Coroutine\"></a></h1><h2 id=\"什么是协程\">什么是协程?<a href=\"post/Unity_Lifecycle_Coroutine#什么是协程\"></a></h2><p><del>“可以被控制的Update函数”!!!</del></p>\n<p>既然我们讨论的是Unity里的协程，因此我们先来康康Unity官方的对协程的解释吧— —</p>\n<blockquote>\n<p>A coroutine is a function that can <strong>suspend its execution</strong> until the given YieldInstruction finishes.</p>\n<blockquote>\n<p>协程是一个可以<strong>暂停执行</strong>的函数，并且可以被挂起直到给定的yield指令完成(后再被唤醒并运行其后续的工作内容）.</p>\n</blockquote>\n</blockquote>\n<p>从官方的解释您可以看出，协程是在主线程中的一个函数，虽然它看起来独立于主线程在进行调用，但其实并不是一个线程。</p>\n<p>协程可以视作是部分执行的函数，并假定在适当的条件得到满足，在未来的某一时刻将被恢复，直到它的工作完成。</p>\n<p>因此您在使用协程时不需要担心多线程同步或锁之类的问题，同时协程在性能上、相比于一般函数几乎没有更多的开销。因此在使用协程时，您只需要关注其应该在什么情况下挂起，又在什么情况下重新被唤醒即可。</p>\n<p>而协程的部分执行使协程可以很好的控制跨越一定帧数后执行的行为，在开发游戏时，会给您带来极大的便利，也会使您的代码看上去会更加优雅<strong>;D</strong></p>\n<h2 id=\"协程在脚本里是怎么存在的\">协程在脚本里是怎么存在的?<a href=\"post/Unity_Lifecycle_Coroutine#协程在脚本里是怎么存在的\"></a></h2><p>同样的，我们先来问问神奇的官方文档吧!</p>\n<blockquote>\n<p>Normal coroutine updates are run after the Update function returns. A coroutine is a function that can suspend its execution (yield) until the given YieldInstruction finishes.</p>\n<p>协程(Coroutine)的运行是在生命周期函数(Lifecycle)中的Update函数后.</p>\n</blockquote>\n<p>然后让我们来康康Unity内部对协程的实现是如何的吧!</p>\n<pre><code>public interface IEnumerator{\n    object Current { get; }\n    bool MoveNext();\n    void Reset();\n}\n\npublic interface IEnumerable{\n    [DispId(-4)]\n    IEnumerator GetEnumerator();\n}</code></pre><p>协程函数的实现说到底内部是一个IEnumerator（迭代器），IEnumerator 接口中有两个方法 Current 和 MoveNext()。</p>\n<p>因此协程函数遇到yield return时，将会记录此次位置并开始迭代器中的MoveNext()的运行，而Unity将在Update()每帧结束后都询问每个协程是否满足条件，如果MoveNext()返回true，即此时已满足了特定条件，Unity将让协程函数从上次结束位置继续执行。</p>\n<h2 id=\"协程的使用流程主要是怎么样的\">协程的使用流程主要是怎么样的?<a href=\"post/Unity_Lifecycle_Coroutine#协程的使用流程主要是怎么样的\"></a></h2><h3 id=\"启动协程\">启动协程<a href=\"post/Unity_Lifecycle_Coroutine#启动协程\"></a></h3><p>通过MonoBehaviour提供的StartCoroutine方法来实现启动协同程序。</p>\n<pre><code>StartCoroutine(IEnumerator routine);    //通过函数开始一个协程\n\nStartCoroutine (methodName:string, value : object = null);        //通过函数名开始一个协程</code></pre><p>您可以在项目中的CoroutineTestScene进行验证，我们可以得到以下结论：</p>\n<div class=\"article-bounded\"><div class=\"article-table\"><table>\n<thead>\n<tr>\n<th>所用方法</th>\n<th>方便之处</th>\n<th>不便之处</th>\n</tr>\n</thead>\n<tbody><tr>\n<td>通过函数开始</td>\n<td>可以传入多个参数</td>\n<td>不可单独停止此协程</td>\n</tr>\n<tr>\n<td>通过函数名开始`</td>\n<td>可以单独停止此协程</td>\n<td>至多传入一个参数</td>\n</tr>\n</tbody></table></div></div>\n<blockquote>\n<p>不过，其实吧，如果想要停止对应的协程的话，大可以设参来记录指定协程后在需要的时候来停止噢。</p>\n<p>这种方法均适用于上述两个开始协程的情况，所以这运用起来差别也不是很大<strong>:P</strong> <del>又说了句废话</del></p>\n</blockquote>\n<h3 id=\"停止协程\">停止协程<a href=\"post/Unity_Lifecycle_Coroutine#停止协程\"></a></h3><pre><code>StopCoroutine(string methodName);    //按函数名停止该脚本中指定协程\n\nStopCoroutine(Coroutine method);    //按参数停止该脚本中指定协程\n\nStopAllCoroutine();        //停止该脚本中所有协程</code></pre><p>StopCoroutine()一般只能靠函数名与指定的Coroutine参数来停止，而StopAllCoroutine()则可以一次性全部关掉。</p>\n<p>当然，在unity3D中，一个脚本是否继续运行是需要在场景中实例化的，因此如果将其挂载的gameobject进行setActive(false)时也可以直接终止该脚本的所有协同程序，并且之后setActive(true)也并不会使协程自动再启动。</p>\n<h3 id=\"挂起协程\">挂起协程<a href=\"post/Unity_Lifecycle_Coroutine#挂起协程\"></a></h3><p>一个协程收到特定指令后会被挂起(暂停执行)，然后其将等待某个条件满足后才继续执行其后续代码。</p>\n<p>在生命周期函数中我们已经讨论过，这个条件满足与否的判断是发生在LateUpdate()后的，即在渲染的每一帧后，Unity都会对这个条件发起询问。</p>\n<p>这个条件的类型有以下类型：</p>\n<p>  ① null -&gt; 等待所有类型的Update()完成后的下一帧执行。</p>\n<p>  ③ WaitForFixedUpdate -&gt; 等待物理周期循环完成后执行</p>\n<p>  ④ WaitForSeconds -&gt; 等待给定的时间周期过完后执行</p>\n<p>  ④ WWW -&gt; 等待www的网络请求完成后执行。</p>\n<p>  ⑤ StartCoroutine -&gt; 开始一个协程并等待此协程完毕后执行。</p>\n<blockquote>\n<p>说起来，招某之前在用 WaitForSeconds()遇到一个坑，<br>就是在想要暂停场景中所有对象的运行但不暂停一个做渐变效果的协程时，我调整了Time.timeScale，此时也会影响WaitForSeconds()的判断。</p>\n<p>即当Time.timeScale = 0f 时，yield return new WaitForSecond(int second) 将永远不会满足噢。</p>\n</blockquote>\n<h2 id=\"协程的运用案例\">协程的运用案例<a href=\"post/Unity_Lifecycle_Coroutine#协程的运用案例\"></a></h2><h3 id=\"一个渐变效果的简单实现\">一个渐变效果的简单实现<a href=\"post/Unity_Lifecycle_Coroutine#一个渐变效果的简单实现\"></a></h3><p>本案例主要关注于循环与协程的一同使用，可以实现逐渐改变的效果。</p>\n<pre><code>IEnumerator Fade()\n{\n    isFading = true;\n    float AlphaValue = m_Renderer.material.color.a;\n    while (AlphaValue &gt; 0f)\n    {\n        AlphaValue -= 0.01f;\n        m_Renderer.material.color = new Color(m_Renderer.material.color.r, m_Renderer.material.color.g, m_Renderer.material.color.b, AlphaValue);\n        yield return null;\n    }\n}\nIEnumerator Show()\n{\n    isFading = false;\n    float AlphaValue = m_Renderer.material.color.a;\n    while (AlphaValue &lt; 1f)\n    {\n        AlphaValue += 0.01f;\n        m_Renderer.material.color = new Color(m_Renderer.material.color.r, m_Renderer.material.color.g, m_Renderer.material.color.b, AlphaValue);\n        yield return null;\n    }\n}</code></pre><p>您可以在本配套项目中的GradualChangeScene中查看效果。</p>\n<h3 id=\"一个无聊的自动播放对话器\">一个无聊的自动播放对话器<a href=\"post/Unity_Lifecycle_Coroutine#一个无聊的自动播放对话器\"></a></h3><p>本案例主要关注于多个协程的配合，可以做到随时开始独立计时的效果。</p>\n<pre><code>IEnumerator WaitForTime()\n{\n    yield return new WaitForSeconds(waitingTime);\n}\nIEnumerator Speaking()\n{\n    isSpeaking = !isSpeaking;\n    yield return WaitForTime();\n    text.text = (&quot;现在已经过了&quot; + waitingTime + &quot;s惹，我可以说话了。&quot;);\n    yield return WaitForTime();\n    text.text = (&quot;又过了&quot; + waitingTime + &quot;s，我累了，我不说话惹。&quot;);\n    yield return WaitForTime();\n    text.text = (&quot;当然如果您还想听我说话的话，您可以再按一次O键噢(小声&quot;);\n    isSpeaking = !isSpeaking;\n}</code></pre><p>您可以在项目中的变AutoDialogueScene中查看效果。</p>\n<h3 id=\"一个愚蠢的自动巡逻实现\">一个愚蠢的自动巡逻实现<a href=\"post/Unity_Lifecycle_Coroutine#一个愚蠢的自动巡逻实现\"></a></h3><p>本案例主要关注于协程的嵌套，可以做到定时循环的效果。</p>\n<pre><code>IEnumerator MoveOnPath()\n{\n    do\n    {\n        foreach (var point in path)\n            yield return StartCoroutine(MoveToPosition(point));\n    }\n    while (true);\n}\n\nIEnumerator MoveToPosition(Vector3 target)\n{\n    while (transform.position != target)\n    {\n        transform.position = Vector3.MoveTowards(transform.position, target, moveSpeed * Time.deltaTime);\n        yield return 0;\n    }\n}</code></pre><p>您可以在项目中的变AutoPatrolScene中查看效果。</p>\n<hr>\n<blockquote>\n<p>本文就分享到这啦<strong>xD</strong><br>因为招某还是超菜一人，若有哪处讲错的话，欢迎您点点左边的联系方式来告诉招某噢!!!</p>\n<p>感谢您的阅读<strong>;D</strong></p>\n<blockquote>\n<p>参考资料</p>\n<p><a href=\"https://docs.unity3d.com/Manual/ExecutionOrder.html\" target=\"_blank\" rel=\"noopener\">生命周期函数(官方文档)</a></p>\n<p><a href=\"https://docs.unity3d.com/ScriptReference/Coroutine.html\" target=\"_blank\" rel=\"noopener\">协程函数(官方文档)</a></p>\n<p><a href=\"https://www.iteye.com/blog/dsqiu-2029701\" target=\"_blank\" rel=\"noopener\">DSQiu佬的协程原理剖析</a></p>\n</blockquote>\n</blockquote>\n<hr>\n","next":{"title":"Hello World!!!","link":"post/HelloWorld!!!"},"plink":"http://blog.ColloidalZhao.com/post/Unity_Lifecycle_Coroutine/","toc":[{"title":"关于Unity的生命周期函数(Lifecycle)","id":"关于Unity的生命周期函数-Lifecycle","index":"1","children":[{"title":"首次加载(First Scene load)","id":"首次加载-First-Scene-load","index":"1.1"},{"title":"协程(Coroutine)","id":"协程-Coroutine","index":"1.2"},{"title":"更新顺序(Update Order)","id":"更新顺序-Update-Order","index":"1.3"}]},{"title":"关于协程(Coroutine)","id":"关于协程-Coroutine","index":"2","children":[{"title":"什么是协程?","id":"什么是协程","index":"2.1"},{"title":"协程在脚本里是怎么存在的?","id":"协程在脚本里是怎么存在的","index":"2.2"},{"title":"协程的使用流程主要是怎么样的?","id":"协程的使用流程主要是怎么样的","index":"2.3","children":[{"title":"启动协程","id":"启动协程","index":"2.3.1"},{"title":"停止协程","id":"停止协程","index":"2.3.2"},{"title":"挂起协程","id":"挂起协程","index":"2.3.3"}]},{"title":"协程的运用案例","id":"协程的运用案例","index":"2.4","children":[{"title":"一个渐变效果的简单实现","id":"一个渐变效果的简单实现","index":"2.4.1"},{"title":"一个无聊的自动播放对话器","id":"一个无聊的自动播放对话器","index":"2.4.2"},{"title":"一个愚蠢的自动巡逻实现","id":"一个愚蠢的自动巡逻实现","index":"2.4.3"}]}]}]}